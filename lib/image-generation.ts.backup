import { VertexAI } from '@google-cloud/vertexai';
import sharp from 'sharp';
import type { GenerateCoordinateImageRequest } from '@/types/coordinate';

// 이미지 생성 모델 이름 (Imagen 3)
const imageModel = 'imagen-3.0-generate-002';

/**
 * Vertex AI 클라이언트 가져오기 (이미지 생성용)
 * Gemini 2.5 Flash Image는 특정 리전에서만 지원됨
 */
function getVertexAI(): VertexAI {
  if (!process.env.GOOGLE_CLOUD_PROJECT) {
    throw new Error('GOOGLE_CLOUD_PROJECT 환경 변수가 설정되지 않았습니다.');
  }

  // 이미지 생성 모델은 us-central1 또는 global 리전 사용
  const imageGenerationLocation = process.env.GOOGLE_CLOUD_IMAGE_LOCATION || 'us-central1';

  // Google Cloud 인증 설정
  const vertexConfig: any = {
    project: process.env.GOOGLE_CLOUD_PROJECT,
    location: imageGenerationLocation,
  };

  // JSON 형식의 credentials가 있으면 직접 전달
  if (process.env.GOOGLE_APPLICATION_CREDENTIALS_JSON) {
    try {
      const credentials = JSON.parse(process.env.GOOGLE_APPLICATION_CREDENTIALS_JSON);
      vertexConfig.googleAuthOptions = {
        credentials,
      };
    } catch (error) {
      console.error('GOOGLE_APPLICATION_CREDENTIALS_JSON 파싱 오류:', error);
    }
  }

  return new VertexAI(vertexConfig);
}

/**
 * 코디네이션 이미지 생성 요청을 위한 서버 타입
 */
interface GenerateImageRequestServer extends GenerateCoordinateImageRequest {
  userImageBuffer?: Buffer;
  userImageMimeType?: string;
}

/**
 * 이미지를 1024x800으로 리사이징
 */
async function convertToHorizontalAspect(base64Image: string): Promise<string> {
  try {
    // Base64를 Buffer로 변환
    const imageBuffer = Buffer.from(base64Image, 'base64');

    // 이미지 메타데이터 가져오기
    const metadata = await sharp(imageBuffer).metadata();
    const { width = 1024, height = 1024 } = metadata;

    console.log(`원본 이미지 크기: ${width}x${height}`);

    // 목표 크기: 1024x800
    const targetWidth = 1024;
    const targetHeight = 800;

    console.log(`목표 크기: ${targetWidth}x${targetHeight}`);

    // 이미지를 1024x800으로 리사이징 (비율 유지하면서 fit)
    const processedBuffer = await sharp(imageBuffer)
      .resize(targetWidth, targetHeight, {
        fit: 'contain', // 비율 유지하면서 1024x800 안에 맞춤
        background: { r: 255, g: 255, b: 255, alpha: 1 } // 흰색 배경
      })
      .toBuffer();

    // 다시 Base64로 변환
    const processedBase64 = processedBuffer.toString('base64');
    console.log('이미지 리사이징 완료 (1024x800)');

    return processedBase64;
  } catch (error) {
    console.error('이미지 변환 오류:', error);
    // 오류 시 원본 반환
    return base64Image;
  }
}

/**
 * 분석 결과를 기반으로 코디네이션 이미지 생성
 */
export async function generateCoordinateImageFromAnalysis(
  request: GenerateImageRequestServer
) {
  try {
    const vertex_ai = getVertexAI();
    const generativeModel = vertex_ai.preview.getGenerativeModel({
      model: imageModel,
    });

    // 이미지 생성을 위한 프롬프트 생성
    const prompt = createImageGenerationPrompt(request);

    // 로케일에 따른 시스템 프롬프트 설정
    const isEastAsian = request.locale === 'ko' || request.locale === 'ja';
    const ethnicityNote = isEastAsian
      ? ' Models must have East Asian (Korean or Japanese) features and appearance.'
      : '';

    // 시스템 프롬프트 추가
    const systemPrompt = `You are a professional fashion photography AI. Generate fashion lookbook images with people arranged horizontally (side by side) in the center. CRITICAL: Use PURE WHITE background (#FFFFFF) only - no gray, no neutral tones.${ethnicityNote}`;

    console.log('===== 이미지 생성 프롬프트 =====');
    console.log('시스템 프롬프트:', systemPrompt);
    console.log('메인 프롬프트:', prompt);

    // 컨텐츠 parts 구성
    const parts: any[] = [
      {
        text: systemPrompt,
      },
    ];

    // 사용자 이미지가 있으면 추가
    if (request.userImageBuffer && request.userImageMimeType) {
      const userImageBase64 = request.userImageBuffer.toString('base64');
      parts.push({
        inlineData: {
          mimeType: request.userImageMimeType,
          data: userImageBase64,
        },
      });
    }

    // 프롬프트 추가
    parts.push({
      text: prompt,
    });

    // Gemini API 호출 (이미지 생성)
    const result = await generativeModel.generateContent({
      contents: [
        {
          role: 'user',
          parts,
        },
      ],
      generationConfig: {
        temperature: 0.4, // 창의성을 위해 약간 높임
        topK: 32,
        topP: 1,
        maxOutputTokens: 8192,
        candidateCount: 1, // 이미지 1장만 생성
      },
    });

    const response = result.response;

    // 디버깅: 전체 응답 구조 로깅
    console.log('===== Gemini API 응답 =====');
    console.log('전체 응답:', JSON.stringify(response, null, 2));

    // 생성된 이미지가 있는지 확인
    const candidates = response.candidates;
    if (!candidates || candidates.length === 0) {
      console.error('응답에 candidates가 없습니다.');
      throw new Error('이미지 생성 실패: 응답이 없습니다.');
    }

    console.log('Candidates 개수:', candidates.length);
    console.log('첫 번째 candidate:', JSON.stringify(candidates[0], null, 2));

    // 이미지 데이터 추출
    const responseParts = candidates[0]?.content?.parts;
    if (!responseParts || responseParts.length === 0) {
      console.error('응답에 parts가 없습니다.');
      throw new Error('이미지 생성 실패: 이미지 데이터가 없습니다.');
    }

    console.log('Parts 개수:', responseParts.length);
    console.log('Parts 구조:', JSON.stringify(responseParts, null, 2));

    // inlineData에서 이미지 추출
    let imageData = null;
    for (const part of responseParts) {
      console.log('Part 키:', Object.keys(part));
      if (part.inlineData) {
        imageData = part.inlineData.data;
        console.log('이미지 데이터 발견! 길이:', imageData?.length);
        break;
      }
    }

    if (!imageData) {
      console.error('모든 part를 확인했지만 inlineData를 찾을 수 없습니다.');
      console.error('Parts 내용:', JSON.stringify(responseParts, null, 2));
      throw new Error('이미지 생성 실패: 이미지를 찾을 수 없습니다.');
    }

    // 이미지를 가로 비율로 변환
    const convertedImageData = await convertToHorizontalAspect(imageData);

    // Base64 이미지 URL 생성
    const imageUrl = `data:image/png;base64,${convertedImageData}`;

    return {
      imageUrl,
    };
  } catch (error) {
    console.error('이미지 생성 오류:', error);
    throw error;
  }
}

/**
 * 이미지 생성을 위한 프롬프트 생성
 */
function createImageGenerationPrompt(
  request: GenerateCoordinateImageRequest
): string {
  const { bodyInfo, styleOptions, tpo, bodyConcerns, stylingTips, colorPalette, locale } = request;

  // 액세서리 리스트 생성
  const accessoriesText = request.accessories.length > 0
    ? request.accessories.map(acc => acc.name).join(', ')
    : '없음';

  // 성별에 따른 모델 설명
  const genderDescription = bodyInfo.gender === '남성' ? 'male model' : 'female model';

  // 체격에 따른 설명
  const bodyTypeMap: { [key: string]: string } = {
    '마른': 'slim/lean',
    '보통': 'average/normal',
    '통통': 'fuller/curvy',
    '근육질': 'athletic/muscular',
  };

  // 어깨 너비 설명
  const shoulderWidthMap: { [key: string]: string } = {
    '좁음': 'narrow shoulders',
    '보통': 'average shoulders',
    '넓음': 'broad shoulders',
  };

  // 체형 비율 설명
  const bodyShapeMap: { [key: string]: string } = {
    '역삼각형': 'inverted triangle body shape (shoulders > hips)',
    '삼각형': 'triangle body shape (hips > shoulders)',
    '직사각형': 'rectangle body shape (straight silhouette)',
    '모래시계': 'hourglass body shape (defined waist)',
    '원형': 'round body shape',
    '사다리꼴': 'trapezoid body shape (slightly broader shoulders)',
  };

  // 로케일에 따른 인종 설정
  const isEastAsian = locale === 'ko' || locale === 'ja';
  const ethnicityLine = isEastAsian
    ? '- Ethnicity: East Asian (Korean or Japanese) appearance'
    : '';

  const personDescription = `Create a realistic ${genderDescription} with:
${ethnicityLine ? ethnicityLine + '\n' : ''}- Body type: ${bodyTypeMap[bodyInfo.bodyType] || bodyInfo.bodyType}
- ${shoulderWidthMap[bodyInfo.shoulderWidth] || bodyInfo.shoulderWidth}
- ${bodyShapeMap[bodyInfo.bodyShape] || bodyInfo.bodyShape}
- Height: ${bodyInfo.height}cm, Weight: ${bodyInfo.weight}kg
- Skin tone: ${bodyInfo.skinTone === '쿨톤' ? 'cool-toned' : bodyInfo.skinTone === '웜톤' ? 'warm-toned' : 'neutral'}`;

  return `Create a professional fashion lookbook image showing 2 different outfit variations for the same person.

## Person Information
- Height: ${bodyInfo.height}cm, Weight: ${bodyInfo.weight}kg
- Body Type: ${bodyInfo.bodyType}
- Skin Tone: ${bodyInfo.skinTone}
- Body Concerns: ${bodyConcerns.length > 0 ? bodyConcerns.join(', ') : 'None'}

## Occasion (TPO)
${tpo.time}, ${tpo.occasion} at ${tpo.place}

## Style Preferences
${styleOptions.join(', ')}

## Styling Guidelines
${stylingTips.map((tip, idx) => `${idx + 1}. ${tip}`).join('\n')}

## Recommended Colors
${colorPalette.join(', ')}

## Recommended Accessories
${accessoriesText}

---

**LAYOUT:**
- 2 people standing side by side in the CENTER
- PURE WHITE background (#FFFFFF) - NO gray or neutral tones
- Professional fashion photography style

**REQUIREMENTS:**

1. ${personDescription}
2. **TWO full-body figures** (head to toe visible)
3. **Horizontal arrangement**: LEFT person and RIGHT person
4. Full body view for both
5. Two outfit variations:
   - **LEFT**: Formal, classic, sophisticated style
   - **RIGHT**: Casual, modern, colorful style with accessories
6. **CRITICAL: PURE WHITE solid background (#FFFFFF) ONLY** - the entire image background must be completely white, no gray areas
7. Natural lighting, professional quality
8. Both people clearly visible and well-lit

Generate a professional fashion lookbook image with 2 outfit variations.`;
}
